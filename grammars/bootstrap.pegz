{
package main
}

Grammar ← __ initializer:( Initializer __ )? rules:( Rule __ )+ {
    const pos = c.astPos();

    // create the grammar, assign its initializer
    const g = try c.allocator.create(ast.Grammar);
    g.* = ast.Grammar{
        .pos = pos,
        .init = null,
        .rules = std.ArrayList(*ast.Rule).init(c.allocator),
    };

    if (initializer) |init_val| {
        g.init = @as(*ast.CodeBlock, @ptrCast(init_val));
    }

    const rules_slice = @as([]const []const u8, @ptrCast(rules));
    for (rules_slice) |rule_val| {
        const rule_ptr = @as(*ast.Rule, @ptrCast(rule_val));
        try g.rules.append(c.allocator, rule_ptr);
    }

    return g;
}

Initializer ← code:CodeBlock EOS {
    return code;
}

Rule ← name:IdentifierName __ display:( StringLiteral __ )? RuleDefOp __ expr:Expression EOS {
    const pos = c.astPos();

    const rule = try c.allocator.create(ast.Rule);
    rule.* = ast.Rule{
        .pos = pos,
        .name = name.*,
        .display_name = undefined,
        .expression = undefined,
        .expr = undefined,
        .visited = false,
        .nullable = false,
        .left_recursive = false,
        .leader = false,
    };

    if (display) |display_val| {
        rule.display_name = @as(ast.StringLit, @ptrCast(display_val));
    } else {
        rule.display_name = ast.StringLit{
            .pos = pos,
            .value = "",
        };
    }

    const expr_ptr = try c.allocator.create(ast.Expression);
    expr_ptr.* = expr;
    rule.expr = expr_ptr;
    rule.expression = expr;

    return rule;
}

Expression ← ChoiceExpr

ChoiceExpr ← first:ActionExpr rest:( __ "/" __ ActionExpr )* {
    const rest_slice = @as([]const []const u8, @ptrCast(rest));
    if (rest_slice.len == 0) {
        return first;
    }

    const pos = c.astPos();
    const choice = try ast.ChoiceExpr.init(c.allocator, pos);
    try choice.alternatives.append(c.allocator, first);

    for (rest_slice) |sl| {
        const expr = @as(ast.Expression, @ptrCast(sl));
        try choice.alternatives.append(c.allocator, expr);
    }

    return ast.Expression{ .choice = choice };
}

ActionExpr ← expr:SeqExpr code:( __ CodeBlock )? {
    if (code == null) {
        return expr;
    }

    const pos = c.astPos();
    const act = try ast.ActionExpr.init(c.allocator, pos, expr, code.?, 0);
    return ast.Expression{ .action = act };
}

SeqExpr ← first:LabeledExpr rest:( __ LabeledExpr )* {
    const rest_slice = @as([]const []const u8, @ptrCast(rest));
    if (rest_slice.len == 0) {
        return first;
    }
    const seq = try ast.SeqExpr.init(c.allocator, c.astPos());
    try seq.exprs.append(c.allocator, first);
    for (rest_slice) |sl| {
        const expr = @as(ast.Expression, @ptrCast(sl));
        try seq.exprs.append(c.allocator, expr);
    }
    return ast.Expression{ .seq = seq };
}

LabeledExpr ← label:Identifier __ ':' __ expr:PrefixedExpr {
    const pos = c.astPos();
    const lab = try c.allocator.create(ast.LabeledExpr);
    const label_ptr = try c.allocator.create(ast.Identifier);
    label_ptr.* = label.*;
    const expr_ptr = try c.allocator.create(ast.Expression);
    expr_ptr.* = expr;

    lab.* = ast.LabeledExpr{
        .pos = pos,
        .label = label_ptr,
        .expr = expr_ptr,
    };
    return ast.Expression{ .labeled = lab };
} / PrefixedExpr

PrefixedExpr ← op:PrefixedOp __ expr:SuffixedExpr {
    const pos = c.astPos();
    const op_str = @as([]const u8, @ptrCast(op));
    if (std.mem.eql(u8, op_str, "&")) {
        const and_expr = try ast.AndExpr.init(c.allocator, pos, expr);
        return ast.Expression{ .and_expr = and_expr };
    }
    const not_expr = try c.allocator.create(ast.NotExpr);
    const expr_ptr = try c.allocator.create(ast.Expression);
    expr_ptr.* = expr;
    not_expr.* = ast.NotExpr{
        .pos = pos,
        .expr = expr_ptr,
    };
    return ast.Expression{ .not = not_expr };
} / SuffixedExpr

PrefixedOp ← ( '&' / '!' ) {
    return c.text;
}

SuffixedExpr ← expr:PrimaryExpr __ op:SuffixedOp {
    const pos = c.astPos();
    const op_str = @as([]const u8, @ptrCast(op));
    const expr_ptr = try c.allocator.create(ast.Expression);
    expr_ptr.* = expr;

    if (std.mem.eql(u8, op_str, "?")) {
        const zero_or_one = try c.allocator.create(ast.ZeroOrOneExpr);
        zero_or_one.* = ast.ZeroOrOneExpr{
            .pos = pos,
            .expr = expr_ptr,
        };
        return ast.Expression{ .zero_or_one = zero_or_one };
    } else if (std.mem.eql(u8, op_str, "*")) {
        const zero_or_more = try c.allocator.create(ast.ZeroOrMoreExpr);
        zero_or_more.* = ast.ZeroOrMoreExpr{
            .pos = pos,
            .expr = expr_ptr,
        };
        return ast.Expression{ .zero_or_more = zero_or_more };
    } else if (std.mem.eql(u8, op_str, "+")) {
        const one_or_more = try c.allocator.create(ast.OneOrMoreExpr);
        one_or_more.* = ast.OneOrMoreExpr{
            .pos = pos,
            .expr = expr_ptr,
        };
        return ast.Expression{ .one_or_more = one_or_more };
    } else {
        return error.UnknownOperator;
    }
} / PrimaryExpr 

SuffixedOp ← ( '?' / '*' / '+' ) {
    return c.text;
}

PrimaryExpr ← LitMatcher / CharClassMatcher / AnyMatcher / RuleRefExpr / SemanticPredExpr / "(" __ expr:Expression __ ")" {
    return expr;
}
RuleRefExpr ← name:IdentifierName !( __ ( StringLiteral __ )? RuleDefOp ) {
    const ref = try c.allocator.create(ast.RuleRefExpr);
    const name_ptr = try c.allocator.create(ast.Identifier);
    name_ptr.* = name.*;
    ref.* = ast.RuleRefExpr{
        .pos = c.astPos(),
        .name = name_ptr,
        .nullable = false,
    };
    return ast.Expression{ .rule_ref = ref };
}
SemanticPredExpr ← op:SemanticPredOp __ code:CodeBlock {
    const op_str = @as([]const u8, @ptrCast(op));
    if (std.mem.eql(u8, op_str, "&")) {
        const and_code = try c.allocator.create(ast.AndCodeExpr);
        and_code.* = ast.AndCodeExpr{
            .pos = c.astPos(),
            .code = code,
            .func_ix = 0,
        };
        return ast.Expression{ .and_code = and_code };
    }
    const not_code = try c.allocator.create(ast.NotCodeExpr);
    not_code.* = ast.NotCodeExpr{
        .pos = c.astPos(),
        .code = code,
        .func_ix = 0,
    };
    return ast.Expression{ .not_code = not_code };
}
SemanticPredOp ← ( '&' / '!' ) {
    return c.text;
}

RuleDefOp ← '=' / "<-" / '\u2190' / '\u27f5'

SourceChar ← .
Comment ← MultiLineComment / SingleLineComment
MultiLineComment ← "/*" ( !"*/" SourceChar )* "*/"
MultiLineCommentNoLineTerminator ← "/*" ( !( "*/" / EOL ) SourceChar )* "*/"
SingleLineComment ← "//" ( !EOL SourceChar )*

Identifier ← IdentifierName
IdentifierName ← IdentifierStart IdentifierPart* {
    return ast.Identifier{
        .pos = c.astPos(),
        .value = try c.allocator.dupe(u8, c.text),
    };
}
IdentifierStart ← [a-z_]i
IdentifierPart ← IdentifierStart / [0-9]

LitMatcher ← lit:StringLiteral ignore:"i"? {
    const raw_str = lit.value;
    const unquoted = try std.mem.replaceOwned(u8, c.allocator, raw_str, "\"", "");
    const lit_matcher = try c.allocator.create(ast.LitMatcher);
    lit_matcher.* = ast.LitMatcher{
        .pos = c.astPos(),
        .value = unquoted,
        .ignore_case = ignore != null,
    };
    return ast.Expression{ .lit_matcher = lit_matcher };
}
StringLiteral ← ( '"' DoubleStringChar* '"' / "'" SingleStringChar "'" / '`' RawStringChar* '`' ) {
    return ast.StringLit{
        .pos = c.astPos(),
        .value = try c.allocator.dupe(u8, c.text),
    };
}
DoubleStringChar ← !( '"' / "\\" / EOL ) SourceChar / "\\" DoubleStringEscape
SingleStringChar ← !( "'" / "\\" / EOL ) SourceChar / "\\" SingleStringEscape
RawStringChar ← !'`' SourceChar

DoubleStringEscape ← '"' / CommonEscapeSequence
SingleStringEscape ← "'" / CommonEscapeSequence

CommonEscapeSequence ← SingleCharEscape / OctalEscape / HexEscape / LongUnicodeEscape / ShortUnicodeEscape
SingleCharEscape ← 'a' / 'b' / 'n' / 'f' / 'r' / 't' / 'v' / '\\'
OctalEscape ← OctalDigit OctalDigit OctalDigit
HexEscape ← 'x' HexDigit HexDigit
LongUnicodeEscape ← 'U' HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit HexDigit
ShortUnicodeEscape ← 'u' HexDigit HexDigit HexDigit HexDigit

OctalDigit ← [0-7]
DecimalDigit ← [0-9]
HexDigit ← [0-9a-f]i

CharClassMatcher ← '[' ( ClassCharRange / ClassChar / "\\" UnicodeClassEscape )* ']' 'i'? {
    const pos = c.astPos();
    const char_class = try c.allocator.create(ast.CharClassMatcher);
    const chars = std.ArrayList(u8).init(c.allocator);
    const ranges = std.ArrayList(struct { u8, u8 }).init(c.allocator);
    const unicode_classes = std.ArrayList([]const u8).init(c.allocator);

    char_class.* = ast.CharClassMatcher{
        .pos = pos,
        .value = try c.allocator.dupe(u8, c.text),
        .ignore_case = false,
        .inverted = false,
        .chars = chars,
        .ranges = ranges,
        .unicode_classes = unicode_classes,
    };
    return ast.Expression{ .char_class_matcher = char_class };
}
ClassCharRange ← ClassChar '-' ClassChar
ClassChar ← !( "]" / "\\" / EOL ) SourceChar / "\\" CharClassEscape
CharClassEscape ← ']' / CommonEscapeSequence

UnicodeClassEscape ← 'p' ( SingleCharUnicodeClass / '{' UnicodeClass '}' )
SingleCharUnicodeClass ← [LMNCPZS]
UnicodeClass ← [a-z_]i+

AnyMatcher ← "." {
    const any_matcher = try c.allocator.create(ast.AnyMatcher);
    any_matcher.* = ast.AnyMatcher{
        .pos = c.astPos(),
        .value = try c.allocator.dupe(u8, c.text),
    };
    return ast.Expression{ .any_matcher = any_matcher };
}

CodeBlock ← "{" Code "}" {
    const pos = c.astPos();
    const code_block = try c.allocator.create(ast.CodeBlock);
    code_block.* = ast.CodeBlock{
        .pos = pos,
        .value = try c.allocator.dupe(u8, c.text),
    };
    return code_block;
}

Code ← ( ( ![{}] SourceChar )+ / "{" Code "}" )*

__ ← ( Whitespace / EOL / Comment )*
_ ← ( Whitespace / MultiLineCommentNoLineTerminator )*

Whitespace ← [ \t\r]
EOL ← '\n'
EOS ← __ ';' / _ SingleLineComment? EOL / __ EOF

EOF ← !.