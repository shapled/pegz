const std = @import("std");
const ast = @import("pegz_common").ast;

/// Token ID type
pub const Tid = enum(i32) {
    invalid = -1,
    eof = 0, // end-of-file token, id 0

    // identifiers follow the same rules as Go (start at 127 to avoid conflicts with ASCII)
    ident = 127,
    ruledef, // rule definition token

    // literals
    char, // character literal, as in Go ('a'i?)
    str, // double-quoted string literal, as in Go ("string"i?)
    rstr, // back-tick quoted raw string literal, as in Go (`string`i?)
    class, // square-brackets character classes ([a\n\t]i?)
    lcomment, // line comment as in Go (// comment or /* comment */ with no newline)
    mlcomment, // multi-line comment as in Go (/* comment */)
    code, // code blocks between '{' and '}'

    // operators and delimiters have the value of their char
    eol = '\n', // end-of-line token, required in the parser
    colon = ':', // separate variable name from expression ':'
    semicolon = ';', // optional ';' to terminate rules
    lparen = '(', // parenthesis to group expressions '('
    rparen = ')', // ')'
    dot = '.', // any matcher '.'
    ampersand = '&', // and-predicate '&'
    exclamation = '!', // not-predicate '!'
    question = '?', // zero-or-one '?'
    plus = '+', // one-or-more '+'
    star = '*', // zero-or-more '*'
    slash = '/', // ordered choice '/'

    const Self = @This();

    pub fn toString(self: @This()) []const u8 {
        return switch (self) {
            .invalid => "invalid",
            .eof => "eof",
            .ident => "ident",
            .ruledef => "ruledef",
            .char => "char",
            .str => "str",
            .rstr => "rstr",
            .class => "class",
            .lcomment => "lcomment",
            .mlcomment => "mlcomment",
            .code => "code",
            .eol => "eol",
            .colon => "colon",
            .semicolon => "semicolon",
            .lparen => "lparen",
            .rparen => "rparen",
            .dot => "dot",
            .ampersand => "ampersand",
            .exclamation => "exclamation",
            .question => "question",
            .plus => "plus",
            .star => "star",
            .slash => "slash",
        };
    }

    pub fn format(self: *const Self, writer: anytype) !void {
        try writer.writeAll(self.toString());
        try writer.print("({d})", .{@intFromEnum(self.*)});
    }
};

/// Set of blacklisted identifiers (Go keywords and predeclared identifiers)
pub const BlacklistedIdents = struct {
    pub const HashMap = std.StringHashMap(void);

    pub fn init(gpa: std.mem.Allocator) HashMap {
        var map = HashMap.init(gpa);

        // zig keywords https://ziglang.org/documentation/master/#Keyword-Reference
        const keywords = [_][]const u8{
            "addrspace", "align", "allowzero", "and", "anyframe", "anytype", "asm", 
            "break", "callconv", "catch", "comptime", "const", "continue", "defer", 
            "else", "enum", "errdefer", "error", "export", "extern", "fn", "for", 
            "if", "inline", "linksection", "noalias", "noinline", "nosuspend", "opaque", 
            "or", "orelse", "packed", "pub", "resume", "return", "struct", "suspend", 
            "switch", "test", "threadlocal", "try", "union", "unreachable", "var", 
            "volatile", "while",
        };

        // Add keywords
        for (keywords) |kw| {
            map.put(kw, {}) catch unreachable;
        }

        return map;
    }

    pub fn contains(map: HashMap, ident: []const u8) bool {
        return map.contains(ident);
    }
};

/// Token is a syntactic token generated by the scanner.
pub const Token = struct {
    id: Tid,
    lit: []const u8,
    pos: ast.Pos,

    const Self = @This();
    const TOKEN_STRING_LEN = 50;

    pub fn format(self: *const Self, writer: anytype) !void {
        var v = self.lit;
        if (v.len > TOKEN_STRING_LEN) {
            const half = TOKEN_STRING_LEN / 2;
            try writer.print("{}: {} \"{}\"[...]\"{}\"", .{ self.pos, self.id, v[0..half], v[v.len - half ..] });
        } else {
            try writer.print("{}: {} \"{}\"", .{ self.pos, self.id, v });
        }
    }

    pub fn toString(self: @This(), gpa: std.mem.Allocator) ![]const u8 {
        return std.fmt.allocPrint(gpa, "{}: {s} \"{s}\"", .{ self.pos, self.id, self.lit });
    }
};
