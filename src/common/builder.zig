const std = @import("std");
const ast = @import("ast.zig");

/// Options configuration for the builder
pub const Options = struct {
    receiver_name: []const u8 = "c",
    optimize: bool = false,
    basic_latin_lookup_table: bool = false,
    global_state: bool = false,
    nolint: bool = false,
    support_left_recursion: bool = false,
};

/// Error types for builder operations
pub const BuilderError = error{
    GrammarError,
    LeftRecursionError,
    InvalidExpression,
    TemplateError,
    WriteFailed,
    OutOfMemory,
};

/// Template strings for generated code
const CODE_GENERATED_COMMENT = "// Code generated by pigeon; DO NOT EDIT.\n\n";

// Template strings - in Zig we'll use comptime functions instead of templates
const ON_FUNC_TEMPLATE = "fn {s}(self *Self, {s}) any!error {{\n{s}\n}}\n";
const ON_PRED_FUNC_TEMPLATE = "fn {s}(self *Self, {s}) bool!error {{\n{s}\n}}\n";
const ON_STATE_FUNC_TEMPLATE = "fn {s}(self *Self, {s}) error! {{\n{s}\n}}\n";
const CALL_FUNC_TEMPLATE =
    \\fn call{s}(p *Self) any!error {{
    \\    return p.cur.{s}({s});
    \\}}
;
const CALL_PRED_FUNC_TEMPLATE =
    \\fn call{s}(p *Self) bool!error {{
    \\    return p.cur.{s}({s});
    \\}}
;
const CALL_STATE_FUNC_TEMPLATE =
    \\fn call{s}(p *Self) error! {{
    \\    return p.cur.{s}({s});
    \\}}
;

/// Builder generates parser code for a given grammar
pub const Builder = struct {
    allocator: std.mem.Allocator,
    writer: std.io.Writer,
    err: ?BuilderError = null,

    // Options
    options: Options,

    // State
    rule_name: []const u8 = "",
    expr_index: usize = 0,
    args_stack: std.ArrayList(std.ArrayList([]const u8)),
    range_table: bool = false,

    pub fn init(allocator: std.mem.Allocator, writer: std.io.Writer, options: Options) !Builder {
        return Builder{
            .allocator = allocator,
            .writer = writer,
            .options = options,
            .args_stack = try std.ArrayList(std.ArrayList([]const u8)).initCapacity(allocator, 0),
        };
    }

    /// BuildParser builds a PEG parser using the provided grammar
    pub fn buildParser(self: *Builder, grammar: *ast.Grammar) !void {
        // Prepare and validate grammar (simplified version)
        const have_left_recursion = try self.prepareGrammar(grammar);

        if (!self.options.support_left_recursion and have_left_recursion) {
            self.err = BuilderError.LeftRecursionError;
            return BuilderError.LeftRecursionError;
        }

        // Write the different sections
        try self.writeInit(grammar.init);
        try self.writeGrammar(grammar);

        for (grammar.rules.items) |rule| {
            try self.writeRuleCode(rule);
        }

        try self.writeStaticCode();
    }

    fn prepareGrammar(self: *Builder, grammar: *ast.Grammar) !bool {
        _ = self;
        _ = grammar;
        // This would implement grammar preparation and left recursion detection
        // For now, return false (no left recursion detected)
        return false;
    }

    fn writeInit(self: *Builder, initBlock: ?*ast.CodeBlock) !void {
        if (initBlock) |code| {
            // Remove opening and closing braces and add generated comment
            const val = code.value[1..code.value.len - 1];
            try self.writer.writeAll(CODE_GENERATED_COMMENT);
            try self.writer.writeAll(val);
            try self.writer.writeAll("\n");
        }
    }

    fn writeGrammar(self: *Builder, g: *ast.Grammar) !void {
        try self.writer.writeAll("const g = &Grammar{\n");
        try self.writer.writeAll("    .rules = &[_]*Rule{\n");

        for (g.rules.items) |rule| {
            try self.writeRuleRef(rule);
        }

        try self.writer.writeAll("    },\n");
        try self.writer.writeAll("};\n");
    }

    fn writeRuleRef(self: *Builder, r: *ast.Rule) !void {
        if (r.name.value.len == 0) return;

        self.expr_index = 0;
        self.rule_name = r.name.value;

        try self.writer.writeAll("    &.{\n");
        try self.writer.print("        .name = \"{s}\",\n", .{r.name.value});

        if (r.display_name.value.len > 0) {
            try self.writer.print("        .display_name = \"{s}\",\n", .{r.display_name.value});
        }

        const pos = r.pos;
        try self.writer.print("        .pos = Position{{ .line = {d}, .column = {d}, .offset = {d} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.writeAll("        .expr = ");
        try self.writeExpr(r.expr);

        if (r.leader) {
            try self.writer.writeAll("        .leader = true,\n");
        }
        if (r.left_recursive) {
            try self.writer.writeAll("        .left_recursive = true,\n");
        }

        try self.writer.writeAll("    },\n");
    }

    fn writeExpr(self: *Builder, expr: *ast.Expression) BuilderError!void {
        self.expr_index += 1;

        switch (expr.*) {
            .action => |act| try self.writeActionExpr(act),
            .and_code => |and_code| try self.writeAndCodeExpr(and_code),
            .and_expr => |and_expr| try self.writeAndExpr(and_expr),
            .any_matcher => |any| try self.writeAnyMatcher(any),
            .char_class_matcher => |char_class| try self.writeCharClassMatcher(char_class),
            .choice => |choice| try self.writeChoiceExpr(choice),
            .labeled => |labeled| try self.writeLabeledExpr(labeled),
            .lit_matcher => |lit| try self.writeLitMatcher(lit),
            .not_code => |not_code| try self.writeNotCodeExpr(not_code),
            .not => |not_expr| try self.writeNotExpr(not_expr),
            .one_or_more => |one_or_more| try self.writeOneOrMoreExpr(one_or_more),
            .recovery => |recovery| try self.writeRecoveryExpr(recovery),
            .rule_ref => |rule_ref| try self.writeRuleRefExpr(rule_ref),
            .seq => |seq| try self.writeSeqExpr(seq),
            .state_code => |state_code| try self.writeStateCodeExpr(state_code),
            .throw => |throw| try self.writeThrowExpr(throw),
            .zero_or_more => |zero_or_more| try self.writeZeroOrMoreExpr(zero_or_more),
            .zero_or_one => |zero_or_one| try self.writeZeroOrOneExpr(zero_or_one),
        }
    }

    fn writeActionExpr(self: *Builder, act: *ast.ActionExpr) BuilderError!void {
        try self.writer.writeAll("&ActionExpr{\n");
        const pos = act.pos;
        try self.writer.print("    .pos = Position{{ .line = {d}, .column = {d}, .offset = {d} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (act.func_ix == 0) {
            act.func_ix = self.expr_index;
        }

        try self.writer.print("    .run = parser.call{s},\n", .{self.rule_name});
        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(act.expr);
        try self.writer.writeAll(",\n},\n");
    }

    fn writeAndCodeExpr(self: *Builder, and_code: *ast.AndCodeExpr) BuilderError!void {
        try self.writer.writeAll("&AndCodeExpr{\n");
        const pos = and_code.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (and_code.func_ix == 0) {
            and_code.func_ix = self.expr_index;
        }

        try self.writer.print("    .run = parser.call{s},\n", .{self.rule_name});
        try self.writer.writeAll("},\n");
    }

    fn writeAndExpr(self: *Builder, and_expr: *ast.AndExpr) BuilderError!void {
        try self.writer.writeAll("&AndExpr{\n");
        const pos = and_expr.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(and_expr.expr);
        try self.writer.writeAll(",\n},\n");
    }

    fn writeAnyMatcher(self: *Builder, any: *ast.AnyMatcher) BuilderError!void {
        try self.writer.writeAll("&AnyMatcher{\n");
        const pos = any.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });
        try self.writer.writeAll("},\n");
    }

    fn writeCharClassMatcher(self: *Builder, char_class: *ast.CharClassMatcher) BuilderError!void {
        try self.writer.writeAll("&CharClassMatcher{\n");
        const pos = char_class.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.print("    .value = \"{s}\",\n", .{char_class.value});

        if (char_class.chars.items.len > 0) {
            try self.writer.writeAll("    .chars = &[_]u21{\n");
            for (char_class.chars.items) |ch| {
                if (char_class.ignore_case) {
                    try self.writer.print("        {d},\n", .{std.ascii.toLower(ch)});
                } else {
                    try self.writer.print("        {d},\n", .{ch});
                }
            }
            try self.writer.writeAll("    },\n");
        }

        if (char_class.ranges.items.len > 0) {
            try self.writer.writeAll("    .ranges = &[_]struct { u21, u21 }{\n");
            for (char_class.ranges.items) |range| {
                if (char_class.ignore_case) {
                    try self.writer.print("        .{{ {}, {} }},\n",
                        .{ std.ascii.toLower(range[0]), std.ascii.toLower(range[1]) });
                } else {
                    try self.writer.print("        .{{ {}, {} }},\n", .{ range[0], range[1] });
                }
            }
            try self.writer.writeAll("    },\n");
        }

        if (self.options.basic_latin_lookup_table) {
            try self.writer.writeAll("    .basic_latin_chars = ");
            // Would implement BasicLatinLookup equivalent
            try self.writer.writeAll("undefined,\n");
        }

        try self.writer.print("    .ignore_case = {},\n", .{char_class.ignore_case});
        try self.writer.print("    .inverted = {},\n", .{char_class.inverted});
        try self.writer.writeAll("},\n");
    }

    fn writeChoiceExpr(self: *Builder, choice: *ast.ChoiceExpr) BuilderError!void {
        try self.writer.writeAll("&ChoiceExpr{\n");
        const pos = choice.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (choice.alternatives.items.len > 0) {
            try self.writer.writeAll("    .alternatives = &[_]Expression{\n");
            for (choice.alternatives.items) |alt| {
                try self.writeExpr(alt);
            }
            try self.writer.writeAll("    },\n");
        }
        try self.writer.writeAll("},\n");
    }

    fn writeLabeledExpr(self: *Builder, labeled: *ast.LabeledExpr) BuilderError!void {
        try self.writer.writeAll("&LabeledExpr{\n");
        const pos = labeled.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (labeled.label.value.len > 0) {
            try self.writer.print("    .label = \"{s}\",\n", .{labeled.label.value});
        }

        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(labeled.expr);
        try self.writer.writeAll(",\n},\n");
    }

    fn writeLitMatcher(self: *Builder, lit: *ast.LitMatcher) BuilderError!void {
        try self.writer.writeAll("&LitMatcher{\n");
        const pos = lit.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (lit.ignore_case) {
            const output = try self.allocator.dupe(u8, lit.value);
            defer self.allocator.free(output);
            _ = std.ascii.lowerString(output, lit.value);
            try self.writer.print("    .value = \"{s}\",\n", .{output});
        } else {
            try self.writer.print("    .value = \"{s}\",\n", .{lit.value});
        }

        try self.writer.print("    .ignore_case = {},\n", .{lit.ignore_case});
        try self.writer.print("    .want = \"{s}\",\n", .{lit.value});
        try self.writer.writeAll("},\n");
    }

    fn writeNotCodeExpr(self: *Builder, not_code: *ast.NotCodeExpr) BuilderError!void {
        try self.writer.writeAll("&NotCodeExpr{\n");
        const pos = not_code.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (not_code.func_ix == 0) {
            not_code.func_ix = self.expr_index;
        }

        try self.writer.print("    .run = parser.call{s},\n", .{self.rule_name});
        try self.writer.writeAll("},\n");
    }

    fn writeNotExpr(self: *Builder, not_expr: *ast.NotExpr) BuilderError!void {
        try self.writer.writeAll("&NotExpr{\n");
        const pos = not_expr.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(not_expr.expr);
        try self.writer.writeAll(",\n},\n");
    }

    fn writeOneOrMoreExpr(self: *Builder, one_or_more: *ast.OneOrMoreExpr) BuilderError!void {
        try self.writer.writeAll("&OneOrMoreExpr{\n");
        const pos = one_or_more.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(one_or_more.expr);
        try self.writer.writeAll(",\n},\n");
    }

    fn writeRecoveryExpr(self: *Builder, recovery: *ast.RecoveryExpr) BuilderError!void {
        try self.writer.writeAll("&RecoveryExpr{\n");
        const pos = recovery.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(recovery.expr);
        try self.writer.writeAll("    .recover_expr = ");
        try self.writeExpr(recovery.recover_expr);

        try self.writer.writeAll("    .labels = &[_][]const u8{\n");
        for (recovery.labels.items) |label| {
            try self.writer.print("        \"{s}\",\n", .{label});
        }
        try self.writer.writeAll("    },\n},\n");
    }

    fn writeRuleRefExpr(self: *Builder, rule_ref: *ast.RuleRefExpr) BuilderError!void {
        try self.writer.writeAll("&RuleRefExpr{\n");
        const pos = rule_ref.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.print("    .name = \"{s}\",\n", .{rule_ref.name.value});
        try self.writer.writeAll("},\n");
    }

    fn writeSeqExpr(self: *Builder, seq: *ast.SeqExpr) BuilderError!void {
        try self.writer.writeAll("&SeqExpr{\n");
        const pos = seq.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (seq.exprs.items.len > 0) {
            try self.writer.writeAll("    .exprs = &[_]Expression{\n");
            for (seq.exprs.items) |expr| {
                try self.writeExpr(expr);
            }
            try self.writer.writeAll("    },\n");
        }
        try self.writer.writeAll("},\n");
    }

    fn writeStateCodeExpr(self: *Builder, state_code: *ast.StateCodeExpr) BuilderError!void {
        self.options.global_state = true;
        try self.writer.writeAll("&StateCodeExpr{\n");
        const pos = state_code.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        if (state_code.func_ix == 0) {
            state_code.func_ix = self.expr_index;
        }

        try self.writer.print("    .run = parser.call{s},\n", .{self.rule_name});
        try self.writer.writeAll("},\n");
    }

    fn writeThrowExpr(self: *Builder, throw: *ast.ThrowExpr) BuilderError!void {
        try self.writer.writeAll("&ThrowExpr{\n");
        const pos = throw.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.print("    .label = \"{s}\",\n", .{throw.label});
        try self.writer.writeAll("},\n");
    }

    fn writeZeroOrMoreExpr(self: *Builder, zero_or_more: *ast.ZeroOrMoreExpr) BuilderError!void {
        try self.writer.writeAll("&ZeroOrMoreExpr{\n");
        const pos = zero_or_more.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(zero_or_more.expr);
        try self.writer.writeAll(",\n},\n");
    }

    fn writeZeroOrOneExpr(self: *Builder, zero_or_one: *ast.ZeroOrOneExpr) BuilderError!void {
        try self.writer.writeAll("&ZeroOrOneExpr{\n");
        const pos = zero_or_one.pos;
        try self.writer.print("    .pos = Position{{ .line = {}, .column = {}, .offset = {} }},\n",
            .{ pos.line, pos.column, pos.offset });

        try self.writer.writeAll("    .expr = ");
        try self.writeExpr(zero_or_one.expr);
        try self.writer.writeAll(",\n},\n");
    }

    fn writeRuleCode(self: *Builder, rule: *ast.Rule) !void {
        if (rule.name.value.len == 0) return;

        self.rule_name = rule.name.value;
        try self.pushArgsSet();
        try self.writeExprCode(rule.expr);
        self.popArgsSet();
    }

    fn pushArgsSet(self: *Builder) !void {
        try self.args_stack.append(self.allocator, try std.ArrayList([]const u8).initCapacity(self.allocator, 0));
    }

    fn popArgsSet(self: *Builder) void {
        if (self.args_stack.items.len > 0) {
            var old_set = self.args_stack.orderedRemove(self.args_stack.items.len - 1);
            old_set.deinit(self.allocator);
        }
    }

    fn addArg(self: *Builder, arg: *ast.Identifier) !void {
        if (self.args_stack.items.len == 0) return;

        const current_set = &self.args_stack.items[self.args_stack.items.len - 1];
        try current_set.append(self.allocator, arg.value);
    }

    fn writeExprCode(self: *Builder, expr: *ast.Expression) !void {
        switch (expr.*) {
            .action => |act| {
                try self.writeExprCode(act.expr);
                try self.writeActionExprCode(act);
            },
            .and_code => |and_code| try self.writeAndCodeExprCode(and_code),
            .labeled => |labeled| {
                try self.addArg(labeled.label);
                try self.pushArgsSet();
                try self.writeExprCode(labeled.expr);
                self.popArgsSet();
            },
            .not_code => |not_code| try self.writeNotCodeExprCode(not_code),
            .and_expr => |and_expr| {
                try self.pushArgsSet();
                try self.writeExprCode(and_expr.expr);
                self.popArgsSet();
            },
            .choice => |choice| {
                for (choice.alternatives.items) |alt| {
                    try self.pushArgsSet();
                    try self.writeExprCode(alt);
                    self.popArgsSet();
                }
            },
            .not => |not_expr| {
                try self.pushArgsSet();
                try self.writeExprCode(not_expr.expr);
                self.popArgsSet();
            },
            .one_or_more => |one_or_more| {
                try self.pushArgsSet();
                try self.writeExprCode(one_or_more.expr);
                self.popArgsSet();
            },
            .recovery => |recovery| {
                try self.pushArgsSet();
                try self.writeExprCode(recovery.expr);
                try self.writeExprCode(recovery.recover_expr);
                self.popArgsSet();
            },
            .seq => |seq| {
                for (seq.exprs.items) |sub| {
                    try self.writeExprCode(sub);
                }
            },
            .state_code => |state_code| try self.writeStateCodeExprCode(state_code),
            .zero_or_more => |zero_or_more| {
                try self.pushArgsSet();
                try self.writeExprCode(zero_or_more.expr);
                self.popArgsSet();
            },
            .zero_or_one => |zero_or_one| {
                try self.pushArgsSet();
                try self.writeExprCode(zero_or_one.expr);
                self.popArgsSet();
            },
            else => {}, // Other types don't generate code
        }
    }

    fn writeActionExprCode(self: *Builder, act: *ast.ActionExpr) !void {
        if (act.func_ix > 0) {
            try self.writeFunc(CALL_FUNC_TEMPLATE, ON_FUNC_TEMPLATE, act.func_ix, act.code.value);
            act.func_ix = 0; // prevent duplicates
        }
    }

    fn writeAndCodeExprCode(self: *Builder, and_code: *ast.AndCodeExpr) !void {
        if (and_code.func_ix > 0) {
            try self.writeFunc(CALL_PRED_FUNC_TEMPLATE, ON_PRED_FUNC_TEMPLATE, and_code.func_ix, and_code.code.value);
            and_code.func_ix = 0; // prevent duplicates
        }
    }

    fn writeNotCodeExprCode(self: *Builder, not_code: *ast.NotCodeExpr) !void {
        if (not_code.func_ix > 0) {
            try self.writeFunc(CALL_PRED_FUNC_TEMPLATE, ON_PRED_FUNC_TEMPLATE, not_code.func_ix, not_code.code.value);
            not_code.func_ix = 0; // prevent duplicates
        }
    }

    fn writeStateCodeExprCode(self: *Builder, state_code: *ast.StateCodeExpr) !void {
        if (state_code.func_ix > 0) {
            try self.writeFunc(CALL_STATE_FUNC_TEMPLATE, ON_STATE_FUNC_TEMPLATE, state_code.func_ix, state_code.code.value);
            state_code.func_ix = 0; // prevent duplicates
        }
    }

    fn writeFunc(self: *Builder, comptime call_template: []const u8, comptime func_template: []const u8, func_ix: usize, code: []const u8) !void {
        _ = func_ix;
        
        if (code.len <= 2) return; // empty code block {}

        // Remove braces and trim whitespace
        // const val = std.mem.trim(u8, code[1..code.len-1], " \t\r\n");

        // Generate arguments list
        var args_buffer: std.ArrayList(u8) = .empty;
        defer args_buffer.deinit(self.allocator);

        if (self.args_stack.items.len > 0) {
            const current_set = &self.args_stack.items[self.args_stack.items.len - 1];
            for (current_set.items, 0..) |arg, i| {
                if (i > 0) {
                    try args_buffer.appendSlice(self.allocator, ", ");
                }
                try args_buffer.appendSlice(self.allocator, arg);
            }
        }
        if (args_buffer.items.len > 0) {
            try args_buffer.appendSlice(self.allocator, " any");
        }

        const fn_name = self.rule_name;

        // Write function definition
        try self.writer.print(func_template,
            .{ self.options.receiver_name, fn_name, args_buffer.items });

        // Generate stack access arguments
        args_buffer.clearAndFree(self.allocator);
        var writer = std.io.Writer.Allocating.fromArrayList(self.allocator, &args_buffer).writer;

        if (self.args_stack.items.len > 0) {
            const current_set = &self.args_stack.items[self.args_stack.items.len - 1];
            for (current_set.items, 0..) |arg, i| {
                if (i > 0) {
                    try args_buffer.appendSlice(self.allocator, ", ");
                }

                try writer.print("\"{s}\"", .{arg});
            }
        }

        // Write function call
        try self.writer.print(call_template, .{ fn_name, "todo", args_buffer.items });
    }

    fn writeStaticCode(self: *Builder) !void {
        // Would write static code template
        try self.writer.writeAll("// Static code would be written here\n");

        if (self.range_table) {
            try self.writer.writeAll("// Range table code would be written here\n");
        }
    }

    pub fn deinit(self: *Builder) void {
        while (self.args_stack.items.len > 0) {
            var old_set = self.args_stack.orderedRemove(self.args_stack.items.len - 1);
            old_set.deinit(self.allocator);
        }
        self.args_stack.deinit(self.allocator);
    }
};

/// Public API function to build a parser
pub fn buildParser(writer: std.io.Writer, grammar: *ast.Grammar, options: Options) !void {
    var builder = Builder.init(std.heap.page_allocator, writer, options);
    defer builder.deinit();

    try builder.buildParser(grammar);
}